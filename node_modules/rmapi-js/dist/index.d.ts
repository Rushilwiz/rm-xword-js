/** request types */
export type RequestMethod = "POST" | "GET" | "PUT" | "DELETE" | "PATCH" | "OPTIONS";
/** a tag for an entry */
export interface Tag {
    /** the name of the tag */
    name: string;
    /** the timestamp when this tag was added */
    timestamp: number;
}
/** common properties shared by collections and documents */
export interface EntryCommon {
    /** the document id, a uuid4 */
    id: string;
    /** the current hash of the state of this entry */
    hash: string;
    /** the visible display name of this entry */
    visibleName: string;
    /** the last modified timestamp */
    lastModified: string;
    /** true if the entry is starred in most ui elements */
    pinned: boolean;
    /**
     * the parent of this entry
     *
     * There are two special parents, "" (empty string) for the root directory,
     * and "trash" for the trash
     */
    parent?: string;
    /** any tags the entry might have */
    tags?: Tag[];
}
/** a folder, referred to in the api as a collection */
export interface CollectionEntry extends EntryCommon {
    /** the key for this as a collection */
    type: "CollectionType";
}
/** a file, referred to in the api as a document */
export interface DocumentType extends EntryCommon {
    /** the key to identify this as a document */
    type: "DocumentType";
    /** the type of the file */
    fileType: "epub" | "pdf" | "notebook";
    /** the timestamp of the last time this entry was opened */
    lastOpened: string;
}
/** a remarkable entry for cloud items */
export type Entry = CollectionEntry | DocumentType;
/** an simple entry produced by the upload api */
export interface UploadEntry {
    /** the document id */
    docID: string;
    /** the document hash */
    hash: string;
}
/** the new hash of a modified entry */
export interface HashEntry {
    /** the actual hash */
    hash: string;
}
/** the mapping from old hashes to new hashes after a bulk modify */
export interface HashesEntry {
    /** the mapping from old to new hashes */
    hashes: Record<string, string>;
}
/** stripped down version of RequestInit */
export interface RequestInitLike {
    /** request method */
    readonly method?: RequestMethod | undefined;
    /** request headers */
    readonly headers?: Record<string, string>;
    /** request body */
    readonly body?: ArrayBuffer | string;
}
/** stripped down version of Headers */
export interface HeadersLike {
    /** get a specific header value */
    get(key: string): string | null;
}
/** stripped down version of Response */
export interface ResponseLike {
    /** true if request was successful */
    ok: boolean;
    /** http status */
    status: number;
    /** text associated with status */
    statusText: string;
    /** get response body as text */
    text(): Promise<string>;
}
/** stripped down version of fetch */
export interface FetchLike {
    /** the rough interface to fetch */
    (url: string, options?: RequestInitLike): Promise<ResponseLike>;
}
/** an error that results from a failed request */
export declare class ResponseError extends Error {
    /** the response status number */
    readonly status: number;
    /** the response status text */
    readonly statusText: string;
    constructor(status: number, statusText: string, message: string);
}
/** an error that results from a failed request */
export declare class ValidationError extends Error {
    /** the response status number */
    readonly field: string;
    /** the response status text */
    readonly regex: RegExp;
    constructor(field: string, regex: RegExp, message: string);
}
/** options for registering with the api */
export interface RegisterOptions {
    /**
     * the device description to use
     *
     * Using an improper one will results in the registration being rejected.
     */
    deviceDesc?: "desktop-windows" | "desktop-macos" | "desktop-linux" | "mobile-android" | "mobile-ios" | "browser-chrome" | "remarkable";
    /**
     * the unique id of this device
     *
     * If omitted it will be randomly generated */
    uuid?: string;
    /** The host to use for authorization requests */
    authHost?: string;
    /** a function for making fetch requests, see {@link RemarkableOptions.fetch} for more info */
    fetch?: FetchLike;
}
/**
 * register a device and get the token needed to access the api
 *
 * Have users go to `https://my.remarkable.com/device/browser/connect` and pass
 * the resulting code into this function to get a device token. Persist that
 * token to use the api.
 *
 * @param code - the eight letter code a user got from `https://my.remarkable.com/device/browser/connect`.
 * @returns the device token necessary for creating an api instace. These never expire so persist as long as necessary.
 */
export declare function register(code: string, { deviceDesc, uuid, authHost, fetch, }?: RegisterOptions): Promise<string>;
/** options for getting responses */
export interface GetOptions {
    /**
     * whether to verify the types of the response
     *
     * Omitting will make the results always work, but they might nit return
     * accurate types anymore.
     */
    verify?: boolean | undefined;
}
export interface UploadOptions extends GetOptions {
    /** an optional parent id to set when uploading */
    parent?: string;
}
/**
 * the api for accessing remarkable functions
 */
export interface RemarkableApi {
    /**
     * list all files
     *
     * @example
     * ```ts
     * await api.listFiles();
     * ```
     */
    listFiles(ops?: GetOptions): Promise<Entry[]>;
    /** create a folder */
    createFolder(visibleName: string, opts?: UploadOptions): Promise<UploadEntry>;
    /**
     * upload an epub
     *
     * @example
     * ```ts
     * await api.uploadEpub("My EPub", ...);
     * ```
     *
     * @param visibleName - the name to show for the uploaded epub
     * @param buffer - the epub contents
     */
    uploadEpub(visibleName: string, buffer: ArrayBuffer, opts?: UploadOptions): Promise<UploadEntry>;
    /**
     * upload a pdf
     *
     * @example
     * ```ts
     * await api.uploadPdf("My PDF", ...);
     * ```
     *
     * @param visibleName - the name to show for the uploaded epub
     * @param buffer - the epub contents
     */
    uploadPdf(visibleName: string, buffer: ArrayBuffer, opts?: UploadOptions): Promise<UploadEntry>;
    /**
     * move an entry
     *
     * @example
     * ```ts
     * await api.move(doc.hash, dir.id);
     * ```
     *
     * @param hash - the hash of the file to move
     * @param parent - the id of the directory to move the entry to, "" (root) and "trash" are special parents
     */
    move(hash: string, parent: string, opts?: GetOptions): Promise<HashEntry>;
    /**
     * delete an entry
     *
     * @example
     * ```ts
     * await api.delete(file.hash);
     * ```
     * @param hash - the hash of the entry to delete
     */
    delete(hash: string, opts?: GetOptions): Promise<HashEntry>;
    /**
     * rename an entry
     *
     * @example
     * ```ts
     * await api.rename(file.hash, "new name");
     * ```
     * @param hash - the hash of the entry to rename
     * @param visibleName - the new name to assign
     */
    rename(hash: string, visibleName: string, opts?: GetOptions): Promise<HashEntry>;
    /**
     * move many entries
     *
     * @example
     * ```ts
     * await api.bulkMove([file.hash], dir.id);
     * ```
     *
     * @param hashes - an array of entry hashes to move
     * @param parent - the directory id to move the entries to, "" (root) and "trash" are special ids
     */
    bulkMove(hashes: readonly string[], parent: string, opts?: GetOptions): Promise<HashesEntry>;
    /**
     * delete many entries
     *
     * @example
     * ```ts
     * await api.bulkDelete([file.hash]);
     * ```
     *
     * @param hashes - the hashes of the entries to delete
     */
    bulkDelete(hashes: readonly string[], opts?: GetOptions): Promise<HashesEntry>;
}
/** options for a remarkable instance */
export interface RemarkableOptions {
    /**
     * the fetch method to use
     *
     * This should loosely conform to the WHATWG fetch, but is relaxed enough that
     * node-fetch also works. This will default to the global definitions of
     * fetch.
     *
     * In node you can either use `"node-fetch"`, or `node --experimental-fetch`
     * for node 17.5 or higher.
     *
     * @defaultValue globalThis.fetch
     */
    fetch?: FetchLike;
    /**
     * the url for making authorization requests
     *
     * @defaultValue "https://webapp-prod.cloud.remarkable.engineering"
     */
    authHost?: string;
    /**
     * the url for making synchronization requests
     *
     * @defaultValue "https://internal.cloud.remarkable.com"
     */
    syncHost?: string;
}
/**
 * create an instance of the api
 *
 * This gets a temporary authentication token with the device token. If
 * requests start failing, simply recreate the api instance.
 *
 * @param deviceToken - the device token proving this api instance is
 *    registered. Create one with {@link register}.
 * @returns an api instance
 */
export declare function remarkable(deviceToken: string, { fetch, authHost, syncHost, }?: RemarkableOptions): Promise<RemarkableApi>;
