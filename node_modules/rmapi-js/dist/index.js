/**
 * Create and interact with reMarkable cloud.
 *
 * After getting a device token with the {@link register | `register`} method,
 * persist it and create api instances using {@link remarkable | `remarkable`}.
 * Outside of registration, all relevant methods are in
 * {@link RemarkableApi | `RemarkableApi`}.
 *
 * @example
 * A simple rename
 * ```ts
 * import { register, remarkable } from "rmapi-js";
 *
 * const code = "..."  // eight letter code from https://my.remarkable.com/device/browser/connect
 * const token = await register(code)
 * // persist token
 * const api = await remarkable(token);
 * const [first, ...rest] = api.listfiles();
 * // rename first file
 * const api.rename(first.hash, "new name");
 * ```
 *
 * @example
 * A simple upload
 * ```ts
 * import { remarkable } from "rmapi-js";
 *
 * const api = await remarkable(...);
 * const entry = await api.putEpub("document name", epubBuffer);
 * await api.create(entry);
 * ```
 *
 * @remarks
 *
 * The cloud api is essentially a collection of entries. Each entry has an id,
 * which is a uuid4 and a hash, which indicates it's current state, and changes
 * as the item mutates, where the id is constant. Most mutable operations take
 * the initial hash so that merge conflicts can be resolved. Each entry has a
 * number of properties, but a key is the `parent`, which represents its parent
 * in the file structure. This will be another document id, or one of two
 * special ids, "" (the empty string) for the root directory, or "trash" for the
 * trash.
 *
 * @packageDocumentation
 */
import { fromByteArray } from "base64-js";
import { boolean, discriminator, elements, enumeration, float64, properties, string, values, } from "jtd-ts";
import { v4 as uuid4 } from "uuid";
const AUTH_HOST = "https://webapp-prod.cloud.remarkable.engineering";
const SYNC_HOST = "https://web.eu.tectonic.remarkable.com";
const idReg = /^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}||trash)$/;
const hashReg = /^[0-9a-f]{64}$/;
/** simple verification wrapper that allows for bypassing */
function verification(res, schema, verify) {
    if (!verify || schema.guard(res)) {
        return res;
    }
    else {
        throw new Error(`couldn't validate schema: ${JSON.stringify(res)} didn't match schema ${JSON.stringify(schema.schema())}`);
    }
}
const commonProperties = {
    id: string(),
    hash: string(),
    visibleName: string(),
    lastModified: string(),
    pinned: boolean(),
};
const commonOptionalProperties = {
    parent: string(),
    tags: elements(properties({
        name: string(),
        timestamp: float64(),
    })),
};
const entry = discriminator("type", {
    CollectionType: properties(commonProperties, commonOptionalProperties, true),
    DocumentType: properties({
        ...commonProperties,
        lastOpened: string(),
        fileType: enumeration("epub", "pdf", "notebook"),
    }, commonOptionalProperties, true),
});
const entries = elements(entry);
const uploadEntry = properties({
    docID: string(),
    hash: string(),
});
const hashEntry = properties({ hash: string() });
const hashesEntry = properties({
    hashes: values(string()),
});
/** an error that results from a failed request */
export class ResponseError extends Error {
    /** the response status number */
    status;
    /** the response status text */
    statusText;
    constructor(status, statusText, message) {
        super(message);
        this.status = status;
        this.statusText = statusText;
    }
}
/** an error that results from a failed request */
export class ValidationError extends Error {
    /** the response status number */
    field;
    /** the response status text */
    regex;
    constructor(field, regex, message) {
        super(message);
        this.field = field;
        this.regex = regex;
    }
}
/**
 * register a device and get the token needed to access the api
 *
 * Have users go to `https://my.remarkable.com/device/browser/connect` and pass
 * the resulting code into this function to get a device token. Persist that
 * token to use the api.
 *
 * @param code - the eight letter code a user got from `https://my.remarkable.com/device/browser/connect`.
 * @returns the device token necessary for creating an api instace. These never expire so persist as long as necessary.
 */
export async function register(code, { deviceDesc = "browser-chrome", uuid = uuid4(), authHost = AUTH_HOST, fetch = globalThis.fetch, } = {}) {
    if (code.length !== 8) {
        throw new Error(`code should be length 8, but was ${code.length}`);
    }
    const resp = await fetch(`${authHost}/token/json/2/device/new`, {
        method: "POST",
        headers: {
            Authorization: "Bearer",
        },
        body: JSON.stringify({
            code,
            deviceDesc,
            deviceID: uuid,
        }),
    });
    if (!resp.ok) {
        throw new ResponseError(resp.status, resp.statusText, "couldn't register api");
    }
    else {
        return await resp.text();
    }
}
/** the implementation of that api */
class Remarkable {
    #userToken;
    #fetch;
    #syncHost;
    constructor(userToken, fetch, syncHost) {
        this.#userToken = userToken;
        this.#fetch = fetch;
        this.#syncHost = syncHost;
    }
    /** make an authorized request to remarkable */
    async #authedFetch(url, { body, method = "POST", headers = {}, }) {
        const resp = await this.#fetch(url, {
            method,
            headers: {
                Authorization: `Bearer ${this.#userToken}`,
                ...headers,
            },
            body,
        });
        if (!resp.ok) {
            const msg = await resp.text();
            throw new ResponseError(resp.status, resp.statusText, `failed reMarkable request: ${msg}`);
        }
        else {
            return resp;
        }
    }
    /** a generic request to the new files api
     *
     * @param meta - remarkable metadata to set, often json formatted or empty
     * @param method - the http method to use
     * @param contentType - the http content type to set
     * @param body - body content, often raw bytes or json
     * @param hash - the hash of a specific file to target
     */
    async #fileRequest({ meta = "", method = "GET", 
    // eslint-disable-next-line spellcheck/spell-checker
    contentType = "text/plain;charset=UTF-8", body, hash, } = {}) {
        const encoder = new TextEncoder();
        const encMeta = encoder.encode(meta);
        const suffix = hash === undefined ? "" : `/${hash}`;
        const resp = await this.#authedFetch(`${this.#syncHost}/doc/v2/files${suffix}`, {
            body,
            method,
            headers: {
                "content-type": contentType,
                "rm-meta": fromByteArray(encMeta),
                "rm-source": "WebLibrary",
            },
        });
        const raw = await resp.text();
        return JSON.parse(raw);
    }
    /** list all files */
    async listFiles({ verify = true } = {}) {
        const res = await this.#fileRequest();
        return verification(res, entries, verify);
    }
    /** upload a file */
    async #uploadFile(parent, visibleName, buffer, contentType, verify) {
        if (verify && !idReg.test(parent)) {
            throw new ValidationError(parent, idReg, "parent must be a valid document id");
        }
        const res = await this.#fileRequest({
            meta: JSON.stringify({ parent, file_name: visibleName }),
            method: "POST",
            contentType,
            body: buffer,
        });
        return verification(res, uploadEntry, verify);
    }
    /** create a folder */
    async createFolder(visibleName, { parent = "", verify = true } = {}) {
        return await this.#uploadFile(parent, visibleName, new ArrayBuffer(0), "folder", verify);
    }
    /** upload an epub */
    async uploadEpub(visibleName, buffer, { parent = "", verify = true } = {}) {
        return await this.#uploadFile(parent, visibleName, buffer, "application/epub+zip", verify);
    }
    /** upload a pdf */
    async uploadPdf(visibleName, buffer, { parent = "", verify = true } = {}) {
        return await this.#uploadFile(parent, visibleName, buffer, "application/pdf", verify);
    }
    async #modify(hash, properties, verify) {
        if (verify && !hashReg.test(hash)) {
            throw new ValidationError(hash, hashReg, "hash to modify was not a valid hash");
        }
        // this does not allow setting pinned, although I don't know why
        const res = await this.#fileRequest({
            hash,
            body: JSON.stringify(properties),
            method: "PATCH",
        });
        return verification(res, hashEntry, verify);
    }
    /** move an entry */
    async move(hash, parent, { verify = true } = {}) {
        if (verify && !idReg.test(parent)) {
            throw new ValidationError(parent, idReg, "parent must be a valid document id");
        }
        return await this.#modify(hash, { parent }, verify);
    }
    /** delete an entry */
    async delete(hash, opts = {}) {
        return await this.move(hash, "trash", opts);
    }
    /** rename an entry */
    async rename(hash, visibleName, { verify = true } = {}) {
        return await this.#modify(hash, { file_name: visibleName }, verify);
    }
    /** bulk modify hashes */
    async #bulkModify(hashes, properties, verify) {
        if (verify) {
            const invalidHashes = hashes.filter((hash) => !hashReg.test(hash));
            if (invalidHashes.length) {
                throw new ValidationError(hashes.join(", "), hashReg, "hashes to modify were not a valid hashes");
            }
        }
        // this does not allow setting pinned, although I don't know why
        const res = await this.#fileRequest({
            body: JSON.stringify({
                updates: properties,
                hashes,
            }),
            method: "PATCH",
        });
        return verification(res, hashesEntry, verify);
    }
    /** move many hashes */
    async bulkMove(hashes, parent, { verify = true } = {}) {
        if (verify && !idReg.test(parent)) {
            throw new ValidationError(parent, idReg, "parent must be a valid document id");
        }
        return await this.#bulkModify(hashes, { parent }, verify);
    }
    /** delete many hashes */
    async bulkDelete(hashes, opts = {}) {
        return await this.bulkMove(hashes, "trash", opts);
    }
}
/**
 * create an instance of the api
 *
 * This gets a temporary authentication token with the device token. If
 * requests start failing, simply recreate the api instance.
 *
 * @param deviceToken - the device token proving this api instance is
 *    registered. Create one with {@link register}.
 * @returns an api instance
 */
export async function remarkable(deviceToken, { fetch = globalThis.fetch, authHost = AUTH_HOST, syncHost = SYNC_HOST, } = {}) {
    const resp = await fetch(`${authHost}/token/json/2/user/new`, {
        method: "POST",
        headers: {
            Authorization: `Bearer ${deviceToken}`,
        },
    });
    if (!resp.ok) {
        throw new Error(`couldn't fetch auth token: ${resp.statusText}`);
    }
    const userToken = await resp.text();
    return new Remarkable(userToken, fetch, syncHost);
}
