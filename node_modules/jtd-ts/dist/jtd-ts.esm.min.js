function P(T){const x=T.match(i);if(!x)return!1;const[,J,K,U,z,Q,X]=x.map((Z)=>parseInt(Z));return 0<K&&K<=12&&U<=p(J,K)&&z<24&&Q<60&&X<=60}var p=function(T,x){if(x===2)return o(T)?29:28;return s[x-1]},o=function(T){return T%4===0&&(T%100!==0||T%400===0)};function $(T){return typeof T==="object"&&T!==null&&!Array.isArray(T)}var i=/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$/,s=[31,0,31,30,31,30,31,31,30,31,30,31],R={int8:[-128,128],int16:[-32768,32768],int32:[-2147483648,2147483648],uint8:[0,256],uint16:[0,65536],uint32:[0,4294967296]};function O(T=0.5){return Math.random()<T}function A(T,x){return T+Math.floor(Math.random()*(x-T))}function Y(T){return T[A(0,T.length)]}function N(){if(L===void 0){const T=Math.sqrt(-2*Math.log(Math.random())),x=2*Math.PI*Math.random();return L=T*Math.sin(x),T*Math.cos(x)}else{const T=L;return L=void 0,T}}function W(T=1){const x=Math.exp(-T);let J=0,K=Math.random();while(K>x)J++,K*=Math.random();return J}function G(T){return Array(T).fill(null).map(()=>E.charAt(Math.floor(Math.random()*E.length))).join("")}var L,E="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ;,'\"";function*B(...T){for(let x of T)yield*x}function*_(T,x){let J=0;for(let K of T)yield x(K,J++)}function*w(T,x){let J=0;for(let K of T)if(x(K,J++))yield K}function*g(T){for(let x=0;x<T;++x)yield x}function a(T){return new f(T)}function e(T,x){return new k(T,x)}function TT(){return new C}function xT(){return new j}function JT(){return new I("int8")}function KT(){return new I("uint8")}function QT(){return new I("int16")}function UT(){return new I("uint16")}function WT(){return new I("int32")}function XT(){return new I("uint32")}function ZT(){return new V("float32")}function $T(){return new V("float64")}function GT(){return new b}function IT(){return new u}function OT(...T){const x=new Set(T);if(x.size!==T.length)throw new Error("enum can't contain duplicates");else return new y(T,x)}function YT(T){if(T.definitions)throw new Error("definitions can only exist on a root schema");else return new v(T)}function _T(T){if(T.definitions)throw new Error("definitions can only exist on a root schema");else return new h(T)}var H=function(T,x,J){const K=new Set(_(B(T??[],x??[]),([U])=>U));if(T?.some(([,U])=>U.definitions))throw new Error("definitions can only exist on a root schema");else if(x?.some(([,U])=>U.definitions))throw new Error("definitions can only exist on a root schema");else if(K.size!==(T?.length??0)+(x?.length??0))throw new Error("properties and optionalProperties keys must be unique");else return new c(T,x,J??!1,K)};function AT(T,x,J){return H(T?Object.entries(T):void 0,x?Object.entries(x):void 0,J)}var n=function(T,x,J){if(J.some(([,K])=>K.definitions))throw new Error("definitions can only exist on a root schema");else if(J.some(([,K])=>K.keys?.has(T)??!0))throw new Error("all discriminator mappings must be properties schemas that don't contain discriminator");else return new d(T,x,J)};function BT(T,x){return n(T,x,Object.entries(x))}function HT(){return new D({},{})}function VT(T){if(typeof T!=="object"||T===null||Array.isArray(T))throw new Error("schema must be an object");const{definitions:x={},...J}=T;if(!$(x))throw new Error("definitions must be an object");return new m(x).compile(J)}class f{#T;definitions;nullable=!0;constructor(T){this.#T=T,this.definitions=T.definitions}guard(T){return T===null||this.#T.guard(T)}fuzz(){return O(0.1)?null:this.#T.fuzz()}schema(){return{...this.#T.schema(),nullable:!0}}}class k{#T;#x;definitions;nullable;constructor(T,x){this.#T=T,this.#x=x,this.definitions=T.definitions,this.nullable=T.nullable}guard(T){return this.#T.guard(T)}fuzz(){return this.#T.fuzz()}schema(){return{...this.#T.schema(),metadata:this.#x}}}class C{guard(T){return T!==void 0}fuzz(){return Y([()=>null,O,N,()=>G(W()),()=>Array(W()).fill(null).map(()=>this.fuzz()),()=>Object.fromEntries(Array(W()).fill(null).map(()=>[G(W(3)),this.fuzz()]))])()}schema(){return{}}}class j{guard(T){return typeof T==="boolean"}fuzz(){return O()}schema(){return{type:"boolean"}}}class I{#T;#x;#J;constructor(T){this.#T=T,[this.#x,this.#J]=R[T]}guard(T){return typeof T==="number"&&T%1===0&&this.#x<=T&&T<this.#J}fuzz(){return A(this.#x,this.#J)}schema(){return{type:this.#T}}}class V{#T;constructor(T){this.#T=T}guard(T){return typeof T==="number"}fuzz(){return N()}schema(){return{type:this.#T}}}class b{guard(T){return typeof T==="string"}fuzz(){return G(W(3))}schema(){return{type:"string"}}}class u{guard(T){return typeof T==="string"&&P(T)}fuzz(){return new Date(Math.random()*3153600000000).toISOString()}schema(){return{type:"timestamp"}}}class y{#T;#x;constructor(T,x){this.#T=T,this.#x=x}guard(T){return typeof T==="string"&&this.#x.has(T)}fuzz(){return Y(this.#T)}schema(){return{enum:[...this.#T]}}}class v{#T;constructor(T){this.#T=T}guard(T){return Array.isArray(T)&&T.every((x)=>this.#T.guard(x))}fuzz(){return Array(W()).fill(null).map(()=>this.#T.fuzz())}schema(){return{elements:this.#T.schema()}}}class h{#T;constructor(T){this.#T=T}guard(T){return $(T)&&Object.values(T).every((x)=>this.#T.guard(x))}fuzz(){return Object.fromEntries(Array(W()).fill(null).map(()=>[G(W(3)),this.#T.fuzz()]))}schema(){return{values:this.#T.schema()}}}class c{#T;#x;#J;keys;constructor(T,x,J,K){this.#T=T,this.#x=x,this.#J=J,this.keys=K}guard(T){return $(T)&&(this.#T?.every(([x,J])=>J.guard(T[x]))??!0)&&(this.#x?.every(([x,J])=>T[x]===void 0||J.guard(T[x]))??!0)&&(this.#J||Object.keys(T).every((x)=>this.keys.has(x)))}fuzz(){const T=_(this.#T??[],([K,U])=>[K,U.fuzz()]),x=_(w(this.#x??[],()=>O()),([K,U])=>[K,U.fuzz()]),J=this.#J?_(g(W()),()=>[G(W(3)),Y([()=>null,O,N,()=>G(W()),()=>[],()=>({})])()]):[];return Object.fromEntries(B(T,x,J))}schema(){const T={};if(this.#T)T.properties=Object.fromEntries(this.#T.map(([x,J])=>[x,J.schema()]));if(this.#x)T.optionalProperties=Object.fromEntries(this.#x.map(([x,J])=>[x,J.schema()]));if(this.#J)T.additionalProperties=!0;return T}}class d{#T;#x;#J;constructor(T,x,J){this.#T=T,this.#x=x,this.#J=J}guard(T){if(!$(T))return!1;const{[this.#T]:x,...J}=T;if(typeof x!=="string")return!1;return this.#x[x]?.guard(J)??!1}fuzz(){const[T,x]=Y(this.#J);return{...x.fuzz(),[this.#T]:T}}schema(){const T=Object.fromEntries(this.#J.map(([x,J])=>[x,J.schema()]));return{discriminator:this.#T,mapping:T}}}class t{#T;#x;definitions=!0;constructor(T,x){this.#T=T,this.#x=x}guard(T){return this.#x.guard(T)}fuzz(){return this.#x.fuzz()}schema(){const T=Object.fromEntries(Object.entries(this.#T).map(([x,J])=>[x,J.schema()]));return{...this.#x.schema(),definitions:T}}}class l{#T;#x;constructor(T,x){this.#T=T,this.#x=x}guard(T){return this.#x.guard(T)}fuzz(){return this.#x.fuzz()}schema(){return{ref:this.#T}}}class D{#T;#x;constructor(T,x){this.#T=T,this.#x=x}def(T,x){const J=x(this.#x);return new D({...this.#T,[T]:J},{...this.#x,[T]:new l(T,J)})}build(T){return new t(this.#T,T(this.#x))}}var zT={boolean:xT,float32:ZT,float64:$T,int8:JT,uint8:KT,int16:QT,uint16:UT,int32:WT,uint32:XT,string:GT,timestamp:IT};class r{#T;#x;constructor(T,x){this.#x=T,this.#T=x}guard(T){return this.#x[this.#T].guard(T)}fuzz(){return this.#x[this.#T].fuzz()}schema(){return{ref:this.#T}}}class m{T;validDefs={};constructor(T){this.defs=T;for(let[x,J]of Object.entries(T))this.validDefs[x]=this.compile(J)}compile(T){let x,J,K,U;if(typeof T!=="object"||T===null||Array.isArray(T))throw new Error("jtd schema must be an object");else if("type"in T){let Q;({type:Q,metadata:J,nullable:K,...U}=T),x=zT[Q]()}else if("enum"in T){let Q;if({enum:Q,metadata:J,nullable:K,...U}=T,!Array.isArray(Q)||Q.length===0||Q.some((X)=>typeof X!=="string"))throw new Error("enum schema enum was not a non-empty array of strings");else x=OT(...Q)}else if("elements"in T){let Q;({elements:Q,nullable:K,metadata:J,...U}=T),x=YT(this.compile(Q))}else if("properties"in T||"optionalProperties"in T){let Q,X,Z;if({properties:Q={},optionalProperties:X={},additionalProperties:Z=!1,nullable:K,metadata:J,...U}=T,!$(Q))throw new Error("properties must be an object");else if(!$(X))throw new Error("optionalProperties must be an object");else if(typeof Z!=="boolean")throw new Error("additionalProperties must be a boolean");const q=Object.entries(Q).map(([F,S])=>[F,this.compile(S)]),M=Object.entries(X).map(([F,S])=>[F,this.compile(S)]);x=Z?H(q,M,!0):H(q,M)}else if("values"in T){let Q;({values:Q,metadata:J,nullable:K,...U}=T),x=_T(this.compile(Q))}else if("ref"in T){let Q;if({ref:Q,nullable:K,metadata:J,...U}=T,this.defs[Q]===void 0)throw new Error(`ref ${Q} was not in definitions`);else x=new r(this.validDefs,Q)}else if("discriminator"in T&&"mapping"in T){let Q,X;if({discriminator:Q,mapping:X,nullable:K,metadata:J,...U}=T,typeof Q!=="string")throw new Error("discriminator was not a string");else if(!$(X))throw new Error("discriminator mapping was not an object");else{const Z=Object.entries(X).map(([q,M])=>[q,this.compile(M)]);x=n(Q,Object.fromEntries(Z),Z)}}else({nullable:K,metadata:J,...U}=T),x=TT();const z=Object.keys(U);if(z.length)throw new Error(`schema had extra keys: ${z.join(", ")}`);else if(K!==void 0&&typeof K!=="boolean")throw new Error("nullable was not a boolean");if(K)x=a(x);if(J!==void 0)x=e(x,J);return x}}export{_T as values,KT as uint8,XT as uint32,UT as uint16,IT as timestamp,GT as string,AT as properties,a as nullable,e as metadata,JT as int8,WT as int32,QT as int16,$T as float64,ZT as float32,OT as enumeration,TT as empty,YT as elements,BT as discriminator,HT as definitions,VT as compile,xT as boolean};
