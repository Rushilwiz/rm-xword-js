/**
 * `jtd-ts` is a typescript first jtd parser, validator, and fuzzer
 *
 * The root of the API is exposed through a {@link CompiledSchema}, which represents a
 * compiled JTD schema and has methods for {@link CompiledSchema#guard | `guard`}ing if an
 * object complies, {@link CompiledSchema#fuzz | `fuzz`}ing random objects, or getting the
 * underlying {@link CompiledSchema#schema `schema`}.
 *
 * There are two primary ways to compile a schema, using native typescript
 * functions, or compiling a raw schema.
 *
 * ## Native Typescript Functions
 *
 * The first is the typescript native way, using functions that have similar
 * names to their JTD counterparts, e.g. {@link boolean}. The advantage of this
 * aproach is that it's a little less verbose, and it skips some checks compared
 * to compiling a raw schema. The disadvantage is that there are some concncepts
 * in JTD that this can not express, primarily, circular refs. This interface
 * doesn't allow declaring an infinite type.

 * Every function except for {@link compile} corresponds to its appropriate
 * schema definition. In addition, there are three functions that behave
 * slightly differently.
 * 1. {@link nullable} - modifies an existing schema to make it nullable
 * 2. {@link metadata} - modifies an existing schema to include metadata, the
 *    type of the metadata is preserved.
 * 3. {@link definitions} - creates a builder to accurately type a directed
 *    acyclic graph of definitions and references, before needing to call
 *    {@link Definitions#build | `build`} to create the actual
 *    {@link CompiledSchema}.
 *
 * ### Usage
 * ```ts
 * import { boolean, properties, float64 } from "jtd-ts";
 *
 * const schema = properties({ bool: boolean() }, { optFloat: float64() });
 *
 * // guard against unknown objects with `.guard()`
 * const obj: unknown = // ...
 * if (schema.guard(obj)) {
 *     obj satisfies { bool: boolean; optFloat?: number };
 * }
 *
 * // create random data that complies with schema with `.fuzz()`
 * const fuzzed: { bool: boolean; optFloat?: number } = schema.fuzz();
 *
 * // get a fully typed output schema with `.schema()`
 * const export: {
 *     properties: { bool: { type: "boolean" } };
 *     optionalProperties: { optFloat: { type: "float64" } };
 * } = schema.schema();
 * ```
 *
 * ## Schema Compilation
 *
 * If you've defined your schema elsewhere, you can similarly just compile it in
 * typescript. The advantage of this is portability, and typescript will infer
 * the appropriate type for the guards. It can also handle circular refs. The
 * downside is it's more verbose, and the type checking doesn't regonize all
 * errors, so if you're not targeting portability, the other interface is
 * better, and can still export the corresponding schema.
 *
 * In addition to the {@link compile} function, this API also exposes interfaces
 * for the various schemas, like {@link BooleanSchema}.
 *
 * ### Usage
 * ```ts
 * import { compile } from "jtd-ts";
 *
 * const schema = compile({
 *     properties: { bool: { type: "boolean" } },
 *     optionalProperties: { optFloat: { type: "float64" } },
 * });
 *
 * // guard against unknown objects with `.guard()`
 * const obj: unknown = // ...
 * if (schema.guard(obj)) {
 *     obj satisfies { bool: boolean; optFloat?: number };
 * }
 *
 * // create random data that complies with schema with `.fuzz()`
 * const fuzzed: { bool: boolean; optFloat?: number } = schema.fuzz();
 * ```
 *
 *
 *
 * @packageDocumentation
 */
import { type IntType } from "./utils";
export { type IntType };
/**
 * a compiled schema that allows various functions
 *
 *
 *
 * @typeParam T - the type that this schema validates
 * @typeParam S - the type of the JTD schema that corresponds to this compiled schema
 */
export interface CompiledSchema<T, S> {
    /**
     * guard for if the input complies with the schema
     *
     * @example
     * const schema = boolean();
     * const val: unknown = // ...
     * if (schema.guard(val)) {
     *     val satisfies boolean;
     * }
     */
    guard(inp: unknown): inp is T;
    /**
     * generate a random item that complies with this schema
     *
     * @example
     * const schema = nullable(boolean());
     * const val: boolean | null = schema.fuzz();
     */
    fuzz(): T;
    /**
     * produce the raw schema
     *
     * @example
     * const schema = nullable(boolean);
     * const raw: { type: "boolean", nullable: true } = schema.schema();
     */
    schema(): S;
    /** @ignore */
    readonly definitions?: true;
    /** @ignore */
    readonly nullable?: true;
    /** @ignore */
    readonly keys?: Readonly<Set<string>>;
}
/**
 * schema that allows null values
 *
 * @example
 * const schema = nullable(boolean());
 */
export declare function nullable<const T, const S>(val: CompiledSchema<T, S>): CompiledSchema<T | null, {
    [K in keyof (S & Record<"nullable", true>)]: (S & Record<"nullable", true>)[K];
}>;
/**
 * add metadata to a schema
 *
 * @example
 * const schema = metadata(boolean(), "flag");
 * const raw: { type: "boolean", metadata: "flag" } = schema.schema();
 */
export declare function metadata<const T, const S, const M>(val: CompiledSchema<T, S>, metadata: M): CompiledSchema<T, {
    [K in keyof (S & Record<"metadata", M>)]: (S & Record<"metadata", M>)[K];
}>;
/** a schema that accepts everything but undefined */
export declare function empty(): CompiledSchema<unknown, {}>;
/** a schema that accepts boolean values */
export declare function boolean(): CompiledSchema<boolean, {
    /** the type definition */
    type: "boolean";
}>;
/** a schema that accepts 8-bit integers */
export declare function int8(): CompiledSchema<number, {
    /** the int8 type */
    type: "int8";
}>;
/** a schema that accepts 8-bit unsigned integers */
export declare function uint8(): CompiledSchema<number, {
    /** the uint8 type */
    type: "uint8";
}>;
/** a schema that accepts 16-bit integers */
export declare function int16(): CompiledSchema<number, {
    /** the int16 type */
    type: "int16";
}>;
/** a schema that accepts 16-bit unsigned integers */
export declare function uint16(): CompiledSchema<number, {
    /** the uint16 type */
    type: "uint16";
}>;
/** a schema that accepts 32-bit integers */
export declare function int32(): CompiledSchema<number, {
    /** the int32 type */
    type: "int32";
}>;
/** a schema that accepts 32-bit unsigned integers */
export declare function uint32(): CompiledSchema<number, {
    /** the uint32 type */
    type: "uint32";
}>;
/** a schema that accepts floats */
export declare function float32(): CompiledSchema<number, {
    /** the float32 type */
    type: "float32";
}>;
/** a schema that accepts floats */
export declare function float64(): CompiledSchema<number, {
    /** the float64 type */
    type: "float64";
}>;
/** a schema that accepts strings */
export declare function string(): CompiledSchema<string, {
    /** the string type */
    type: "string";
}>;
/** a schema that accepts timestamp strings */
export declare function timestamp(): CompiledSchema<string, {
    /** the timestamp type */
    type: "timestamp";
}>;
/**
 * a schema that accepts a limited set of strings
 *
 * @remarks
 * `enum` is a reserved word in typescript, so this is called enumeration.
 *
 * @example
 * const schema = enumeration("a", "b", "c");
 * schema.guard("a");
 */
export declare function enumeration<const V extends readonly [string, ...string[]]>(...values: V): CompiledSchema<V[number], {
    /** the enumerated options */
    enum: [...V];
}>;
/**
 * a schema that accepts arrays of elements
 *
 * @param element - the schema for the element
 *
 * @example
 * const schema = elements(boolean());
 * schema.guard([true]);
 */
export declare function elements<const E, const S>(element: CompiledSchema<E, S>): CompiledSchema<E[], {
    /** the element schema */
    elements: S;
}>;
/**
 * a schema that accepts records with arbitrary keys to the same value
 *
 * @param value - the schema for the record values
 *
 * @example
 * const schema = values(boolean());
 * schema.guard({"a": false});
 */
export declare function values<const V, const S>(value: CompiledSchema<V, S>): CompiledSchema<Record<string, V>, {
    /** the value schema */
    values: S;
}>;
/**
 * a schema that accepts named and optional properties as well as properties not listed
 *
 * This function has many overloads to account for the different ways to specify
 * optional and non-optional properties, However, effectively either `props` or
 * `oprops` must be specified, and additional is a boolean value.
 *
 * @example
 * const schema = properties({ bool: boolean() }, { opt: boolean() }, true);
 */
export declare function properties<const P extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>, const O extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>>(props: P, oprops: O, additional: true): CompiledSchema<{
    -readonly [K in keyof (Required<P> & Partial<O> & Record<string, unknown>)]: (P & O)[K] extends CompiledSchema<infer T, unknown> ? T : unknown;
}, {
    /** the schemas for required properties */
    properties: {
        -readonly [K in keyof P]: P[K] extends CompiledSchema<unknown, infer S> ? S : never;
    };
    /** the schemas for optional properties */
    optionalProperties: {
        -readonly [K in keyof O]: O[K] extends CompiledSchema<unknown, infer S> ? S : never;
    };
    /** if the schema accepts other properties */
    additionalProperties: true;
}>;
/**
 * a schema that accepts named properties as well as properties not listed
 *
 * @example
 * const schema = properties({ bool: boolean() }, undefined, true);
 */
export declare function properties<const P extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>>(props: P, oprops: undefined, additional: true): CompiledSchema<{
    -readonly [K in keyof (Required<P> & Record<string, unknown>)]: P[K] extends CompiledSchema<infer T, unknown> ? T : unknown;
}, {
    /** the schemas for required properties */
    properties: {
        -readonly [K in keyof P]: P[K] extends CompiledSchema<unknown, infer S> ? S : never;
    };
    /** if the schema accepts other properties */
    additionalProperties: true;
}>;
/**
 * a schema that accepts optional properties as well as properties not listed

 * @example
 * const schema = properties(undefined, { opt: boolean() });
 */
export declare function properties<const O extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>>(props: undefined, oprops: O, additional: true): CompiledSchema<{
    -readonly [K in keyof (Partial<O> & Record<string, unknown>)]: O[K] extends CompiledSchema<infer T, unknown> ? T : unknown;
}, {
    /** the schemas for optional properties */
    optionalProperties: {
        -readonly [K in keyof O]: O[K] extends CompiledSchema<unknown, infer S> ? S : never;
    };
    /** if the schema accepts other properties */
    additionalProperties: true;
}>;
/**
 * a schema that accepts named and optional properties
 *
 * @example
 * const schema = properties({ bool: boolean() }, { opt: boolean() });
 */
export declare function properties<const P extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>, const O extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>>(props: P, oprops: O, additional?: false): CompiledSchema<{
    -readonly [K in keyof (Required<P> & Partial<O>)]: (P & O)[K] extends CompiledSchema<infer T, unknown> ? T : never;
}, {
    /** the schemas for required properties */
    properties: {
        -readonly [K in keyof P]: P[K] extends CompiledSchema<unknown, infer S> ? S : never;
    };
    /** the schemas for optional properties */
    optionalProperties: {
        -readonly [K in keyof O]: O[K] extends CompiledSchema<unknown, infer S> ? S : never;
    };
}>;
/**
 * a schema that accepts named properties
 *
 * @example
 * const schema = properties({ bool: boolean() });
 */
export declare function properties<const P extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>>(props: P, oprops?: undefined, additional?: false): CompiledSchema<{
    -readonly [K in keyof Required<P>]: P[K] extends CompiledSchema<infer T, unknown> ? T : never;
}, {
    /** the schemas for required properties */
    properties: {
        -readonly [K in keyof P]: P[K] extends CompiledSchema<unknown, infer S> ? S : never;
    };
}>;
/**
 * a schema that accepts optional properties

 * @example
 * const schema = properties(undefined, { opt: boolean() });
 */
export declare function properties<const O extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>>(props: undefined, oprops: O, additional?: false): CompiledSchema<{
    -readonly [K in keyof Partial<O>]: O[K] extends CompiledSchema<infer T, unknown> ? T : never;
}, {
    /** the schemas for optional properties */
    optionalProperties: {
        -readonly [K in keyof O]: O[K] extends CompiledSchema<unknown, infer S> ? S : never;
    };
}>;
/**
 * a schema that accepts discriminated unions
 *
 * @example
 * const schema = discriminator("choice", {
 *    one: properties({ val: boolean() }),
 *    two: properties({ val: float64() }),
 * })
 * schema.guard({ choice: "one", val: true });
 * schema.guard({ choice: "two", val: 2.0 });
 */
export declare function discriminator<const D extends string, const M extends Record<string, CompiledSchema<Record<string, unknown>, unknown>>>(discriminator: D, mapping: M): CompiledSchema<{
    [K in keyof M]: M[K] extends CompiledSchema<infer P, unknown> ? {
        [Y in keyof (Record<D, K> & P)]: (P & Record<D, K>)[Y];
    } : never;
}[keyof M], {
    /** the discriminator key */
    discriminator: D;
    /** a mapping from discriminator values to schemas */
    mapping: {
        -readonly [K in keyof M]: M[K] extends CompiledSchema<unknown, infer S> ? S : never;
    };
}>;
/** a dictionary of the reference schemas */
export type Refs<D extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>> = {
    [R in keyof D]: D[R] extends CompiledSchema<infer T, unknown> ? CompiledSchema<T, {
        /** the referred to schema */
        ref: R;
    }> : never;
};
/** a type for gradually building a definitions schema */
export interface Definitions<D extends Readonly<Record<string, CompiledSchema<unknown, unknown>>>> {
    /** add a definition */
    def<const R extends string, const T, const S>(name: R, val: (b: Refs<D>) => CompiledSchema<T, S>): Definitions<{
        [K in keyof (D & Record<R, CompiledSchema<T, S>>)]: (D & Record<R, CompiledSchema<T, S>>)[K];
    }>;
    /** build  the definitions into a compiled schema */
    build<const T, const S>(val: (defs: Refs<D>) => CompiledSchema<T, S>): CompiledSchema<T, {
        [K in keyof (S & Record<"definitions", {
            [R in keyof D]: D[R] extends CompiledSchema<unknown, infer S> ? S : never;
        }>)]: (S & Record<"definitions", {
            [R in keyof D]: D[R] extends CompiledSchema<unknown, infer S> ? S : never;
        }>)[K];
    }>;
}
/**
 * creates a builder for a definitions structure
 *
 * This is the only moderately complicated function for building a schema. After
 * creating a schema, you can add a new definition by calling {@link
 * Definitions#def | `def`} with the name of the new definition, and a function
 * that creates it from the current references.
 *
 * @remarks
 * Unlike full JTD, references declared in this way can't be cyclic. You can
 * only reference previously defined references.
 *
 * @example
 * const schema = definitions()
 *     .def("a", () => boolean())
 *     .def("b": ({ a }) => elements(a))
 *     .def("c": ({ a, b }) => properties({ a }, { b }))
 *     .build(({ c }) => c);
 * schema.guard({ a: true, b: [false] });
 * schema.guard({ a: false });
 */
export declare function definitions(): Definitions<{}>;
/** a schema that validates anything */
export interface EmptySchema {
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** a schema that validates a boolean value */
export interface BooleanSchema {
    /** the type */
    readonly type: "boolean";
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** any type that validates a number */
export type NumberType = "float32" | "float64" | IntType;
/** a schema that validates any number */
export interface NumberSchema<N extends NumberType = NumberType> {
    /** the type */
    readonly type: N;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** an type that validates a string */
export type StringType = "string" | "timestamp";
/** a schema that validates any string */
export interface StringSchema<S extends StringType = StringType> {
    /** the type */
    readonly type: S;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** a schema that validates one of a set of strings */
export interface EnumSchema<S extends readonly [string, ...string[]] = readonly [string, ...string[]]> {
    /** an array of all values allowed */
    readonly enum: S;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** a schema that validates an array */
export interface ElementsSchema<S extends SomeSchema = SomeSchema> {
    /** a schema for every element in the array */
    readonly elements: S;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** a schema for an object with required and optional properties */
export interface BothPropertiesSchema<P extends Readonly<Record<string, SomeSchema>> = Readonly<Record<string, SomeSchema>>, O extends Readonly<Record<string, SomeSchema>> = Readonly<Record<string, SomeSchema>>> {
    /** a schema for every required property */
    readonly properties: P;
    /** a schema for every optional property */
    readonly optionalProperties: O;
    /** if non-listed properties are allowed */
    readonly additionalProperties?: boolean;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** a schema for an object with only required properties */
export interface PropertiesSchema<P extends Readonly<Record<string, SomeSchema>> = Readonly<Record<string, SomeSchema>>> {
    /** a schema for every required property */
    readonly properties: P;
    /** properties defines no optional properties */
    readonly optionalProperties?: undefined;
    /** if non-listed properties are allowed */
    readonly additionalProperties?: boolean;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** a schema for an object with only optional properties */
export interface OptionalPropertiesSchema<O extends Readonly<Record<string, SomeSchema>> = Readonly<Record<string, SomeSchema>>> {
    /** optional properties defines no properties */
    readonly properties?: undefined;
    /** a schema for every optional property */
    readonly optionalProperties: O;
    /** if non-listed properties are allowed */
    readonly additionalProperties?: boolean;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** a schema for a dictionary of strings to identical values */
export interface ValuesSchema<S extends SomeSchema = SomeSchema> {
    /** the schema for every value in the mapping */
    readonly values: S;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** any schema that is valid in the mapping section of a discriminator type */
export type MappingSchema = (BothPropertiesSchema | PropertiesSchema | OptionalPropertiesSchema) & {
    /** mapping schemas can't be null */
    readonly nullable?: false;
};
/** a schema for tagged unions of objects */
export interface DiscriminatorSchema<K extends string = string, M extends Readonly<Record<string, MappingSchema>> = Readonly<Record<string, MappingSchema>>> {
    /** the key for the discriminator in the type */
    readonly discriminator: K;
    /** a mapping of discriminator values to schemas */
    readonly mapping: M;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** a schema referencing a predefined definition */
export interface RefSchema<K extends string = string> {
    /** a key with the name of the reference in definitions */
    readonly ref: K;
    /** a key indicating if a type can be null */
    readonly nullable?: boolean;
    /** optional metadata on a schema */
    readonly metadata?: unknown;
}
/** any arbitrary schema */
export type SomeSchema = EmptySchema | BooleanSchema | NumberSchema | StringSchema | EnumSchema | ElementsSchema | BothPropertiesSchema | PropertiesSchema | OptionalPropertiesSchema | ValuesSchema | DiscriminatorSchema | RefSchema;
/** schema for additional properties of a properties type */
export type AdditionalProperties<S extends PropertiesSchema | OptionalPropertiesSchema | BothPropertiesSchema> = S["additionalProperties"] extends true ? Record<string, unknown> : unknown;
/** the data type resulting for a schema that may be nullable */
export type NullableData<S extends SomeSchema> = S["nullable"] extends true ? null : never;
/** the data type compiled by some jtd schema */
export type SchemaData<S extends SomeSchema, R extends Readonly<Record<string, SomeSchema>>> = S extends BooleanSchema ? boolean | NullableData<S> : S extends NumberSchema ? number | NullableData<S> : S extends StringSchema ? string | NullableData<S> : S extends EnumSchema<infer V> ? V[number] | NullableData<S> : S extends ElementsSchema<infer A> ? SchemaData<A, R>[] | NullableData<S> : S extends BothPropertiesSchema<infer P, infer O> ? {
    -readonly [K in keyof (Required<P> & Partial<O> & AdditionalProperties<S>)]: SchemaData<(P & O)[K], R>;
} | NullableData<S> : S extends PropertiesSchema<infer P> ? {
    -readonly [K in keyof (Required<P> & AdditionalProperties<S>)]: SchemaData<P[K], R>;
} | NullableData<S> : S extends OptionalPropertiesSchema<infer O> ? {
    -readonly [K in keyof (Partial<O> & AdditionalProperties<S>)]: SchemaData<O[K], R>;
} | NullableData<S> : S extends ValuesSchema<infer V> ? Record<string, SchemaData<V, R>> | NullableData<S> : S extends RefSchema<infer D> ? D extends keyof R ? SchemaData<R[D], R> | NullableData<S> : never : S extends DiscriminatorSchema<infer D, infer M> ? {
    [K in keyof M]: {
        [DK in D]: K;
    } & SchemaData<M[K], R>;
}[keyof M] | NullableData<S> : unknown;
/**
 * any valid root jtd schema
 *
 * Root schemas may contain definitions referenced by "ref" schemas, whereas
 * nested schemas may not.
 */
export type SomeRootSchema = SomeSchema & {
    /** optional definitions that exist in a root schema */
    definitions?: Readonly<Record<string, SomeSchema>>;
};
/** the datatype compiled by some root schema */
export type RootSchemaData<S extends SomeRootSchema> = SchemaData<S, S["definitions"] extends Readonly<Record<string, SomeSchema>> ? S["definitions"] : {}>;
/**
 * compile a jtd schema
 *
 * If the schema is declared inline and statically, or using the `as const`
 * definition, then this will infer the type that the schema validates. As a
 * result, typescript will accurately infer that `compile({ type: "boolean" })`
 * both {@link CompiledSchema#guard | `guard`}s and
 * {@link CompiledSchema#fuzz | `fuzz`}es boolean values.
 *
 * Since this must check for extensions of the generic {@link SomeRootSchema},
 * typescript will allow extra properties. To get around this, you can check
 * that it `satisfies SomeRootSchema`, which will protect to the type inference,
 * but error for extra properties on object literals. However sometimes, this
 * will also cause problems with infinite types.
 *
 * Other common errors include:
 * - If the guarded type is never, the schema is likely invalid, probably with a
 *   a misspelled ref.
 * - If the schema produces an infinite type, the schema is likely not constant,
 *   and as a result there are an infinite number of types it could validate,
 *   since schemas can be infinitely deep.
 *
 * @example
 * const schema = compile({ properties: { bool: { type: "boolean" } } } satisfies SomeRootSchema);
 */
export declare function compile<const S extends SomeRootSchema>(schema: S): CompiledSchema<RootSchemaData<S>, S>;
